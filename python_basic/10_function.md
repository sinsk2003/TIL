# 함수(function)

- 프로그램을 이루는 기본 단위
- 여러 명령어들의 집합
- 중복되는 명령어들을 줄일 수 있고, 코드의 양이 줄어들기 때문에 효율적인 관리가 가능
- Parameter/매개변수(Argument/인자)를 통해 전달

```
def 함수이름(파라미터, 파라미터, ... ):
  # 함수 블록
```

```python
def function(): # Callee(피호출자)
  print('함수가 실행되었습니다.')

function()  # Caller(호출자)
# '함수가 실행되었습니다.'
```

```python
def add(a, b):
  print( a + b )
  
add(10, 20)  # 파라미터의 개수와 순서에 주의
```

```python
def add(a=0, b=0):	# 기본값 지정
  print( a + b )

add( a + b )	# 0
add( a + b )	# 10
```

- 디폴트가 있는 파라미터와 디폴트가 없는 파라미터를 같이 입력할 때, 디폴트가 없는 파라미터가 반드시 먼저 입력되어야 함

```python
def add(a=0, b):
  print( a + b )
  
# SyntaxError: non-default argument follows default argument
```

```python
def add(a, b=0):
  print( a + b )
  
# # add(10) => a에 들어가면 됨
```

- 입력값 전달: 주소 전달

```python
def function( a ):
  a.reverse()
  print(a)
  
arr = [1, 2, 3, 4]
function(arr)	# [4, 3, 2, 1]

print(arr)	# [4, 3, 2, 1]
```

### 가변인자

- 패킹(Packing): 묶어서 전달

  - 값만 전달하는 경우

  ```python
  def function( *args ):
    print(args)

  function(1,2,3,4,5,6,7,8,9,) # 튜플 형태로 묶어서 전달
  # (1,2,3,4,5,6,7,8,9)
  ```

  - 변수 이름과 함께 전달하는 경우

  ```python
  def function( **kwargs ):
    print( kwargs ) 

  function( a = 1, b = 2, c = 3, d = 4, ) # 딕셔너리 형태로 묶어서 전달
  # {'a': 1, 'b': 2, 'c': 3, 'd': 4}
  ```

  - 두 가지 방법을 함께 사용하는 경우

  ```python
  def function( *args, **kwargs ):
    print(args, kwargs)
    
  function(1, 2, 3, 4, 5, 6, 7, a=1, b=2, c=3 )
  # (1, 2, 3, 4, 5, 6, 7) {'a': 1, 'b': 2, 'c': 3}
  ```

- 언패킹

```python
def function( a, b, c ):
  print(a, b, c)
  
arr = [10, 20, 30] # 리스트로 묶든, 튜플로 묶든, 묶지 않든(튜플로 인식), 결과는 똑같음
function( *arr ) # 10 20 30
```

```python
# 일부는 변수로, 일부는 리스트 형태로 대응
a, b, *c = [1, 2, 3, 4, 5, 6, 7, 8, 9] # 리스트로 묶든, 튜플로 묶든, 묶지 않든, c는 리스트로 반환
print(a, b, c) # 1 2 [3, 4, 5, 6, 7, 8, 9]
```

### 반환이 있는 함수

- return: 실행결과를 Caller한테 돌려줌
  - 함수 내에서만 사용 가능
  - return 명령이 실행되면, 함수는 바로 종료

## 함수의 호출 구조

- 함수는 호출과 함께 실행
  - **콜스택(호출스택): 함수가 호출과 동시에 실행되면 메모리에 만들어지는 함수 고유의 공간**
- 함수 블록 내에서 더 이상 실행할 명령어가 없거나 return 명령어가 실행되면 종료
  - **함수가 종료되면 함수가 사용했던 메모리는 더 이상 존재하지 않음**


### 지역변수(Local Variable)

- 값을 저장하기 위해서 사용하는 메모리의 위치가 두 군데
  - 글로벌 메모리
  - 로컬 메모리(함수가 사용하는 메모리)
- 지역변수: 함수 내에서 정의되어 로컬 메모리에 생성된 변수
  - 함수가 실행되는 동안에만 유지가 되는 변수(함수가 종료되면 참조는 불가능)
  - 파라미터도 지역변수

## 함수의 다양한 종류

- 재귀함수
- 익명함수
- 함수형 문법

### 재귀함수

- 자기 자신을 호출하는 함수

```python
def recursive(n):
  # 기저조건
  if n == 0: return n
  return n + recursive(n-1)

n = 10
recursive(n) # 55
```

### 익명함수

- 람다(Lambda) 이용
- 함수의 이름이 없기 때문에 `익명함수`라고 부름
- 간단하게 한 번만 사용할 때

```
lambda 파라미터: 명령어
```

- 여러줄에 걸친 복잡한 명령은 사용 불가
  - 한 라인에 정의 가능한(간단한)형태를 사용할 때, 유용하게 쓰임

```python
print( (lambda a, b: a + b) ) # <function <lambda> at 0x7f9751467170>
print( (lambda a, b: a + b)(10, 20) ) # 30
```

### 함수형 문법

- 파이썬은 거의 대부분의 문법을 지원
  1. 절차(Procedure)형 프로그래밍
     - `부프로그램`의 의미로 해석 => 함수
     - 소스코드를 함수단위로 관리
       - 소스코드의 재사용성이 증가 => 소스코드의 양이 줄어드는 효과
       - 관리가 더 편해지는 등의 이점
     - 파이썬은 함수만 이용해서 코드를 작성 가능
  2. 객체지향 프로그래밍
     - 함수 단위로 소스코드를 작성해도 해결이 안됨
       - 새로운 개발 방법론이 필요
       - 클래스라는 개념이 도입
         - 함수를 사용했을 때보다 재사용성이 더 증가
         - 완벽하게 버그 없는 소프트웨어를 만들어 내는것은 불가능
         - 기존 언어들의 한계적인 상황
  3. 함수형 프로그래밍
     - 코드를 작성하는 완벽히 새로운 방법
     - 원래도 존재했던 이론 이지만, 현대에 들어서면서 점점 많은 사람들에게 선택되어지기 시작
     - 함수형 언어들은 반복문이 없음
     - 반드시 필요하다면? 재귀를 이용해서 표현은 가능
- 기존 문법의 한계
  - 어떤 집합 x에 대해서, y를 정의할 때, 관계를 나타내는 것이 함수
  - 수학적으로는 이 자체로 완벽
  - 프로그래밍 언어로 표현을 하면서부터 버그가 발생
    - 튜링 구조적인 언어에서는 반드시 반복문의 사용이 필수
    - 이 과정에서 불필요한 코드가 생기고 => 버그가 발생
      - 통계적으로 10줄당 1개의 꼴로 버그가 발생한다는 통계도 있음
      - 안전한 소프트웨어는 만들수 없다


- 파이썬은 완벽하게 함수형 언어처럼 동작 하지는 않지만. 함수형 언어의 일부 기능을 제공

- 실수집합 x에 대한, 정수 집합 y를 가정

  - 실수집합 x와 y를 표현할 수 있는 함수가 필요
  - x와 y사이의 관계는 int()가 될 것임

  ```python
  # 기존의 프로그래밍 언어로는 반복적으로 처리를 해야만 합니다. 
  x = [1.0, 2.0, 3.0, 4.0]
  y = []

  for i in x:
    y.append( int(i) )
  print(y) # [1, 2, 3, 4]

  # 조금 더 파이썬 답게 사용한다면? 
  x = [1.0, 2.0, 3.0, 4.0]
  y = [ int(i) for i in x ]
  print(y) # [1, 2, 3, 4]
  ```

- 파이썬에서 제공되는 함수형 문법: map, filter, reduce

```python
x = [1.0, 2.0, 3.0, 4.0]
print( map(int, x) ) # <map object at 0x7f975149a810>
print( list(map(int, x))) # [1, 2, 3, 4]

# 파이썬의 익명함수를 응용해보면 
# f(x) = 2x와 같은 함수를 가정
x = [1, 2, 3, 4]
list( map(lambda x: 2 * x, x) ) # [2, 4, 6, 8]
```